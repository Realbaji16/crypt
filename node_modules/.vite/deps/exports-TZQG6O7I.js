import {
  AccountController,
  ChainController,
  ConnectionController,
  CoreHelperUtil,
  EventsController,
  LitElement,
  ModalController,
  NetworkUtil,
  OptionsController,
  RouterController,
  SIWXUtil,
  SnackController,
  W3mFrameRpcConstants,
  css,
  customElement,
  html,
  state,
  subscribeKey
} from "./chunk-2RVBP3MC.js";
import {
  Jf,
  Qf,
  Vi,
  Wf,
  Yi
} from "./chunk-FYJ3OPUE.js";
import "./chunk-TI7FWOOO.js";
import {
  proxy,
  ref,
  subscribe
} from "./chunk-EELTKYKY.js";
import "./chunk-XNX5Z5FP.js";
import "./chunk-MZXFFUKN.js";
import "./chunk-X334B5A4.js";
import "./chunk-NPY75PGV.js";
import "./chunk-ONY6HBPH.js";

// node_modules/@reown/appkit-siwe/dist/esm/core/controller/SIWEController.js
var state2 = proxy({
  status: "uninitialized"
});
var SIWEController = {
  state: state2,
  subscribeKey(key, callback) {
    return subscribeKey(state2, key, callback);
  },
  subscribe(callback) {
    return subscribe(state2, () => callback(state2));
  },
  _getClient() {
    if (!state2._client) {
      throw new Error("SIWEController client not set");
    }
    return state2._client;
  },
  async getNonce(address) {
    const client = this._getClient();
    const nonce = await client.getNonce(address);
    this.setNonce(nonce);
    return nonce;
  },
  async getSession() {
    try {
      const client = this._getClient();
      const session = await client.getSession();
      if (session) {
        this.setSession(session);
        this.setStatus("success");
      }
      return session || void 0;
    } catch {
      return void 0;
    }
  },
  createMessage(args) {
    const client = this._getClient();
    const message = client.createMessage(args);
    this.setMessage(message);
    return message;
  },
  async verifyMessage(args) {
    const client = this._getClient();
    const isValid = await client.verifyMessage(args);
    return isValid;
  },
  async signIn() {
    const client = this._getClient();
    const session = await client.signIn();
    return session;
  },
  async signOut() {
    var _a;
    const client = this._getClient();
    await client.signOut();
    this.setStatus("ready");
    this.setSession(void 0);
    (_a = client.onSignOut) == null ? void 0 : _a.call(client);
  },
  onSignIn(args) {
    var _a;
    const client = this._getClient();
    (_a = client.onSignIn) == null ? void 0 : _a.call(client, args);
  },
  onSignOut() {
    var _a;
    const client = this._getClient();
    (_a = client.onSignOut) == null ? void 0 : _a.call(client);
  },
  async setSIWEClient(client) {
    state2._client = ref(client);
    state2.session = await this.getSession();
    state2.status = state2.session ? "success" : "ready";
  },
  setNonce(nonce) {
    state2.nonce = nonce;
  },
  setStatus(status) {
    state2.status = status;
  },
  setMessage(message) {
    state2.message = message;
  },
  setSession(session) {
    state2.session = session;
    state2.status = session ? "success" : "ready";
  }
};

// node_modules/@reown/appkit-siwe/dist/esm/core/utils/ConstantsUtil.js
var ConstantsUtil = {
  FIVE_MINUTES_IN_MS: 3e5
};

// node_modules/@reown/appkit-siwe/dist/esm/src/client.js
var AppKitSIWEClient = class {
  constructor(siweConfig) {
    const { enabled = true, nonceRefetchIntervalMs = ConstantsUtil.FIVE_MINUTES_IN_MS, sessionRefetchIntervalMs = ConstantsUtil.FIVE_MINUTES_IN_MS, signOutOnAccountChange = true, signOutOnDisconnect = true, signOutOnNetworkChange = true, ...siweConfigMethods } = siweConfig;
    this.options = {
      enabled,
      nonceRefetchIntervalMs,
      sessionRefetchIntervalMs,
      signOutOnDisconnect,
      signOutOnAccountChange,
      signOutOnNetworkChange
    };
    this.methods = siweConfigMethods;
  }
  async getNonce(address) {
    const nonce = await this.methods.getNonce(address);
    if (!nonce) {
      throw new Error("siweControllerClient:getNonce - nonce is undefined");
    }
    return nonce;
  }
  async getMessageParams() {
    var _a, _b;
    return await ((_b = (_a = this.methods).getMessageParams) == null ? void 0 : _b.call(_a)) || {};
  }
  createMessage(args) {
    const message = this.methods.createMessage(args);
    if (!message) {
      throw new Error("siweControllerClient:createMessage - message is undefined");
    }
    return message;
  }
  async verifyMessage(args) {
    const isValid = await this.methods.verifyMessage(args);
    return isValid;
  }
  async getSession() {
    const session = await this.methods.getSession();
    if (!session) {
      throw new Error("siweControllerClient:getSession - session is undefined");
    }
    return session;
  }
  async signIn() {
    await SIWXUtil.requestSignMessage();
    const session = await this.methods.getSession();
    if (!session) {
      throw new Error("Error verifying SIWE signature");
    }
    return session;
  }
  async signOut() {
    const siwx = SIWXUtil.getSIWX();
    if (!siwx) {
      return false;
    }
    await siwx.setSessions([]);
    return true;
  }
};

// node_modules/@reown/appkit-siwe/dist/esm/core/helpers/index.js
var ETH_ADDRESS_PATTERN = /0x[a-fA-F0-9]{40}/u;
var ETH_CHAIN_ID_IN_SIWE_PATTERN = /Chain ID: (?<temp1>\d+)/u;
function getAddressFromMessage(message) {
  var _a;
  return ((_a = message.match(ETH_ADDRESS_PATTERN)) == null ? void 0 : _a[0]) || "";
}
function getChainIdFromMessage(message) {
  var _a;
  return `eip155:${((_a = message.match(ETH_CHAIN_ID_IN_SIWE_PATTERN)) == null ? void 0 : _a[1]) || 1}`;
}
async function verifySignature({ address, message, signature, chainId, projectId }) {
  let isValid = Qf(address, message, signature);
  if (!isValid) {
    isValid = await Jf(address, message, signature, chainId, projectId);
  }
  return isValid;
}

// node_modules/@reown/appkit-siwe/dist/esm/scaffold/partials/w3m-connecting-siwe/styles.js
var styles_default = css`
  :host {
    display: flex;
    justify-content: center;
    gap: var(--wui-spacing-2xl);
  }

  wui-visual-thumbnail:nth-child(1) {
    z-index: 1;
  }
`;

// node_modules/@reown/appkit-siwe/dist/esm/scaffold/partials/w3m-connecting-siwe/index.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var W3mConnectingSiwe = class W3mConnectingSiwe2 extends LitElement {
  constructor() {
    var _a, _b;
    super(...arguments);
    this.dappImageUrl = (_a = OptionsController.state.metadata) == null ? void 0 : _a.icons;
    this.walletImageUrl = (_b = AccountController.state.connectedWalletInfo) == null ? void 0 : _b.icon;
  }
  firstUpdated() {
    var _a;
    const visuals = (_a = this.shadowRoot) == null ? void 0 : _a.querySelectorAll("wui-visual-thumbnail");
    if (visuals == null ? void 0 : visuals[0]) {
      this.createAnimation(visuals[0], "translate(18px)");
    }
    if (visuals == null ? void 0 : visuals[1]) {
      this.createAnimation(visuals[1], "translate(-18px)");
    }
  }
  render() {
    var _a;
    return html`
      <wui-visual-thumbnail
        ?borderRadiusFull=${true}
        .imageSrc=${(_a = this.dappImageUrl) == null ? void 0 : _a[0]}
      ></wui-visual-thumbnail>
      <wui-visual-thumbnail .imageSrc=${this.walletImageUrl}></wui-visual-thumbnail>
    `;
  }
  createAnimation(element, translation) {
    element.animate([{ transform: "translateX(0px)" }, { transform: translation }], {
      duration: 1600,
      easing: "cubic-bezier(0.56, 0, 0.48, 1)",
      direction: "alternate",
      iterations: Infinity
    });
  }
};
W3mConnectingSiwe.styles = styles_default;
W3mConnectingSiwe = __decorate([
  customElement("w3m-connecting-siwe")
], W3mConnectingSiwe);

// node_modules/@reown/appkit-siwe/dist/esm/scaffold/views/w3m-connecting-siwe-view/index.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var W3mConnectingSiweView = class W3mConnectingSiweView2 extends LitElement {
  constructor() {
    var _a;
    super(...arguments);
    this.dappName = (_a = OptionsController.state.metadata) == null ? void 0 : _a.name;
    this.isSigning = false;
    this.isCancelling = false;
  }
  render() {
    return html`
      <wui-flex justifyContent="center" .padding=${["2xl", "0", "xxl", "0"]}>
        <w3m-connecting-siwe></w3m-connecting-siwe>
      </wui-flex>
      <wui-flex
        .padding=${["0", "4xl", "l", "4xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100"
          >${this.dappName ?? "Dapp"} needs to connect to your wallet</wui-text
        >
      </wui-flex>
      <wui-flex
        .padding=${["0", "3xl", "l", "3xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="small-400" align="center" color="fg-200"
          >Sign this message to prove you own this wallet and proceed. Canceling will disconnect
          you.</wui-text
        >
      </wui-flex>
      <wui-flex .padding=${["l", "xl", "xl", "xl"]} gap="s" justifyContent="space-between">
        <wui-button
          size="lg"
          borderRadius="xs"
          fullWidth
          variant="neutral"
          ?loading=${this.isCancelling}
          @click=${this.onCancel.bind(this)}
          data-testid="w3m-connecting-siwe-cancel"
        >
          Cancel
        </wui-button>
        <wui-button
          size="lg"
          borderRadius="xs"
          fullWidth
          variant="main"
          @click=${this.onSign.bind(this)}
          ?loading=${this.isSigning}
          data-testid="w3m-connecting-siwe-sign"
        >
          ${this.isSigning ? "Signing..." : "Sign"}
        </wui-button>
      </wui-flex>
    `;
  }
  async onSign() {
    var _a, _b, _c;
    this.isSigning = true;
    EventsController.sendEvent({
      event: "CLICK_SIGN_SIWX_MESSAGE",
      type: "track",
      properties: {
        network: ((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId) || "",
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    try {
      SIWEController.setStatus("loading");
      const session = await SIWEController.signIn();
      SIWEController.setStatus("success");
      EventsController.sendEvent({
        event: "SIWX_AUTH_SUCCESS",
        type: "track",
        properties: {
          network: ((_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.caipNetworkId) || "",
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      return session;
    } catch (error) {
      const preferredAccountType = AccountController.state.preferredAccountType;
      const isSmartAccount = preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT;
      if (isSmartAccount) {
        SnackController.showError("This application might not support Smart Accounts");
      } else {
        SnackController.showError("Signature declined");
      }
      SIWEController.setStatus("error");
      return EventsController.sendEvent({
        event: "SIWX_AUTH_ERROR",
        type: "track",
        properties: {
          network: ((_c = ChainController.state.activeCaipNetwork) == null ? void 0 : _c.caipNetworkId) || "",
          isSmartAccount
        }
      });
    } finally {
      this.isSigning = false;
    }
  }
  async onCancel() {
    var _a;
    this.isCancelling = true;
    const caipAddress = ChainController.state.activeCaipAddress;
    if (caipAddress) {
      await ConnectionController.disconnect();
      ModalController.close();
    } else {
      RouterController.push("Connect");
    }
    this.isCancelling = false;
    EventsController.sendEvent({
      event: "CLICK_CANCEL_SIWX",
      type: "track",
      properties: {
        network: ((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId) || "",
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
  }
};
__decorate2([
  state()
], W3mConnectingSiweView.prototype, "isSigning", void 0);
__decorate2([
  state()
], W3mConnectingSiweView.prototype, "isCancelling", void 0);
W3mConnectingSiweView = __decorate2([
  customElement("w3m-connecting-siwe-view")
], W3mConnectingSiweView);

// node_modules/@reown/appkit-siwe/dist/esm/src/mapToSIWX.js
var subscriptions = [];
function mapToSIWX(siwe) {
  async function getSession() {
    try {
      const response = await siwe.methods.getSession();
      if (!response) {
        return void 0;
      }
      if (!(response == null ? void 0 : response.address)) {
        throw new Error("SIWE session is missing address");
      }
      if (!(response == null ? void 0 : response.chainId)) {
        throw new Error("SIWE session is missing chainId");
      }
      return response;
    } catch (error) {
      console.warn("AppKit:SIWE:getSession - error:", error);
      return void 0;
    }
  }
  async function signOut() {
    var _a, _b;
    await siwe.methods.signOut();
    (_b = (_a = siwe.methods).onSignOut) == null ? void 0 : _b.call(_a);
  }
  subscriptions.forEach((unsubscribe) => unsubscribe());
  subscriptions.push(ChainController.subscribeKey("activeCaipNetwork", async (activeCaipNetwork) => {
    if (!siwe.options.signOutOnNetworkChange) {
      return;
    }
    const session = await getSession();
    const isDifferentNetwork = session && session.chainId !== NetworkUtil.caipNetworkIdToNumber(activeCaipNetwork == null ? void 0 : activeCaipNetwork.caipNetworkId);
    if (isDifferentNetwork) {
      await signOut();
    }
  }), ChainController.subscribeKey("activeCaipAddress", async (activeCaipAddress) => {
    var _a, _b, _c;
    if (siwe.options.signOutOnDisconnect && !activeCaipAddress) {
      const session = await getSession();
      if (session) {
        await signOut();
      }
      return;
    }
    if (siwe.options.signOutOnAccountChange) {
      const session = await getSession();
      const lowercaseSessionAddress = (_a = session == null ? void 0 : session.address) == null ? void 0 : _a.toLowerCase();
      const lowercaseCaipAddress = (_c = (_b = CoreHelperUtil) == null ? void 0 : _b.getPlainAddress(activeCaipAddress)) == null ? void 0 : _c.toLowerCase();
      const isDifferentAddress = session && lowercaseSessionAddress !== lowercaseCaipAddress;
      if (isDifferentAddress) {
        await signOut();
      }
    }
  }));
  return {
    async createMessage(input) {
      var _a, _b;
      const params = await ((_b = (_a = siwe.methods).getMessageParams) == null ? void 0 : _b.call(_a));
      if (!params) {
        throw new Error("Failed to get message params!");
      }
      const nonce = await siwe.getNonce(input.accountAddress);
      const issuedAt = params.iat || (/* @__PURE__ */ new Date()).toISOString();
      const version = "1";
      return {
        nonce,
        version,
        requestId: params.requestId,
        accountAddress: input.accountAddress,
        chainId: input.chainId,
        domain: params.domain,
        uri: params.uri,
        notBefore: params.nbf,
        resources: params.resources,
        statement: params.statement,
        expirationTime: params.exp,
        issuedAt,
        toString: () => siwe.createMessage({
          ...params,
          chainId: NetworkUtil.caipNetworkIdToNumber(input.chainId) || 1,
          address: `did:pkh:${input.chainId}:${input.accountAddress}`,
          nonce,
          version,
          iat: issuedAt
        })
      };
    },
    async addSession(session) {
      var _a, _b;
      const chainId = NetworkUtil.parseEvmChainId(session.data.chainId);
      if (!chainId) {
        return Promise.resolve();
      }
      if (await siwe.methods.verifyMessage(session)) {
        (_b = (_a = siwe.methods).onSignIn) == null ? void 0 : _b.call(_a, {
          address: session.data.accountAddress,
          chainId: NetworkUtil.parseEvmChainId(session.data.chainId)
        });
        return Promise.resolve();
      }
      throw new Error("Failed to verify message");
    },
    async revokeSession(_chainId, _address) {
      try {
        await signOut();
      } catch (error) {
        console.warn("AppKit:SIWE:revokeSession - signOut error", error);
      }
    },
    async setSessions(sessions) {
      if (sessions.length === 0) {
        try {
          await signOut();
        } catch (error) {
          console.warn("AppKit:SIWE:setSessions - signOut error", error);
        }
      } else {
        const session = sessions.find((s) => {
          var _a;
          return s.data.chainId === ((_a = ChainController.getActiveCaipNetwork()) == null ? void 0 : _a.caipNetworkId);
        }) || sessions[0];
        await this.addSession(session);
      }
    },
    async getSessions(chainId, address) {
      var _a;
      try {
        if (!chainId.startsWith("eip155:")) {
          return [
            {
              data: {
                accountAddress: address,
                chainId
              },
              message: "",
              signature: ""
            }
          ];
        }
        const siweSession = await getSession();
        const siweCaipNetworkId = `eip155:${siweSession == null ? void 0 : siweSession.chainId}`;
        const lowercaseSessionAddress = (_a = siweSession == null ? void 0 : siweSession.address) == null ? void 0 : _a.toLowerCase();
        const lowercaseCaipAddress = address == null ? void 0 : address.toLowerCase();
        if (!siweSession || lowercaseSessionAddress !== lowercaseCaipAddress || siweCaipNetworkId !== chainId) {
          return [];
        }
        const session = {
          data: {
            accountAddress: siweSession.address,
            chainId: siweCaipNetworkId
          },
          message: "",
          signature: ""
        };
        return [session];
      } catch (error) {
        console.warn("AppKit:SIWE:getSessions - error:", error);
        return [];
      }
    }
  };
}

// node_modules/@reown/appkit-siwe/dist/esm/exports/index.js
function createSIWEConfig(siweConfig) {
  return new AppKitSIWEClient(siweConfig);
}
export {
  SIWEController,
  W3mConnectingSiwe,
  W3mConnectingSiweView,
  createSIWEConfig,
  Wf as formatMessage,
  getAddressFromMessage,
  getChainIdFromMessage,
  Vi as getDidAddress,
  Yi as getDidChainId,
  mapToSIWX,
  verifySignature
};
//# sourceMappingURL=exports-TZQG6O7I.js.map
